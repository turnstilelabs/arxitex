
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>arXiv Paper Dependency Graph - 2211.11689</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>

    <!-- MATHJAX INTEGRATION -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          packages: {'[+]': ['ams']}
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
          ignoreHtmlClass: 'tex2jax_ignore'
        },
        startup: {
          pageReady: () => {
            return MathJax.startup.defaultPageReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f8f9fa; color: #333; }
        .header { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; }
        h1 { margin: 0 0 10px 0; }
        .stats { display: flex; gap: 20px; flex-wrap: wrap; margin-top: 15px; }
        .stat { background: #e9ecef; padding: 8px 12px; border-radius: 4px; font-size: 14px; }
        .graph-container { background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; }
        .controls { padding: 15px; background: #f8f9fa; border-bottom: 1px solid #dee2e6; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .controls button { padding: 6px 12px; border: 1px solid #dee2e6; background: white; border-radius: 4px; cursor: pointer; font-size: 14px; transition: background-color 0.2s; }
        .controls button:hover { background: #e9ecef; }
        .legend { display: flex; gap: 15px; align-items: center; flex-wrap: wrap; margin-left: auto; }
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 12px; }
        .legend-color { width: 12px; height: 12px; border-radius: 50%; }
        #graph { width: 100%; height: 70vh; cursor: grab; }
        #graph:active { cursor: grabbing; }
        .node { stroke: #fff; stroke-width: 2px; cursor: pointer; }
        .node:hover { stroke: #000; }
        .link { stroke: #999; stroke-opacity: 0.6; stroke-width: 1.5px; transition: stroke-width 0.2s, stroke-opacity 0.2s; cursor: pointer; marker-end: url(#arrowhead); }
        .link:hover { stroke-width: 4px; stroke-opacity: 1; }
        .node-label { font-size: 12px; fill: #333; text-anchor: middle; pointer-events: none; font-weight: 500; }
        .tooltip { position: absolute; background: rgba(0, 0, 0, 0.9); color: white; padding: 12px; border-radius: 6px; font-size: 14px; pointer-events: none; max-width: 450px; z-index: 1000; line-height: 1.6; border: 1px solid #333; }
        .tooltip h4 { margin: 0 0 10px 0; font-size: 16px; border-bottom: 1px solid #555; padding-bottom: 8px; }
        .tooltip p { margin: 5px 0; }
        .tooltip .id-label { color: #aaa; font-family: monospace; font-size: 11px; }
        .tooltip .edge-type { font-weight: bold; color: #ffc107; text-transform: uppercase; }
        .tooltip .math-content { margin-top: 5px; background: #222; padding: 8px; border-radius: 4px; overflow-x: auto; max-height: 300px; overflow-y: auto; }
        .tooltip .error-message { color: #ff6b6b; font-style: italic; font-size: 12px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>arXiv Paper Dependency Graph</h1>
        <p><strong>Paper ID:</strong> 2211.11689 | <strong>Generated:</strong> 2025-11-15 20:10:00</p>
        <div class="stats">
            <div class="stat"><strong>8</strong> artifacts</div>
            <div class="stat"><strong>12</strong> references</div>
        </div>
    </div>
    <div class="graph-container">
        <div class="controls">
            <button id="play-pause">‚è∏Ô∏è Pause</button>
            <button id="reset">üîÑ Reset</button>
            <button id="center">üéØ Center View</button>
            <div class="legend" id="legend-container"></div>
        </div>
        <svg id="graph"></svg>
    </div>
    <div class="tooltip" id="tooltip" style="display: none;"></div>
    <script>
        const graphData = {
  "nodes": [
    {
      "id": "definition-1-b20d1f",
      "type": "definition",
      "content": "A set system $\\F$ is \\emph{union closed} if for all $A,B \\in \\F$ we have $A \\cup B \\in \\F$.",
      "content_preview": "A set system $\\\\F$ is \\\\emph{union closed} if for all $A,B \\\\in \\\\F$ we have $A \\\\cup B \\\\in \\\\F$.",
      "prerequisites_preview": "<b>union closed</b>: A set system is called union closed if for any two sets in the set system their union is also in the set system. A set system $\\\\F$ is \\\\emph{union closed} if for all $A,B \\\\in \\\\F$ we have $A \\\\cup B \\\\in \\\\F$.",
      "display_name": "Definition",
      "label": null,
      "position": {
        "line_start": 47,
        "line_end": 49,
        "col_start": 1,
        "col_end": 17
      },
      "references": [],
      "proof": null
    },
    {
      "id": "definition-2-8354c3",
      "type": "definition",
      "content": "Let $0 \\le c \\le 1$.\nA set system $\\F$ is $c$-approximate union closed if for at least a $c$-fraction of the pairs $A,B \\in \\F$ we have $A \\cup B \\in \\F$.",
      "content_preview": "Let $0 \\\\le c \\\\le 1$.<br>A set system $\\\\F$ is $c$-approximate union closed if for at least a $c$-fraction of the pairs $A,B \\\\in \\\\F$ we have $A \\\\cup B \\\\in \\\\F$.",
      "prerequisites_preview": "<b>union closed</b>: A set system is called union closed if for any two sets in the set system their union is also in the set system. A set system $\\\\F$ is \\\\emph{union closed} if for all $A,B \\\\in \\\\F$ we have $A \\\\cup B \\\\in \\\\F$.<br><br><b>$c$-approximate union closed</b>: A set system $\\\\F$ is $c$-approximate union closed if for at least a $c$-fraction of the pairs $A,B \\\\in \\\\F$ we have $A \\\\cup B \\\\in \\\\F$.",
      "display_name": "Definition",
      "label": null,
      "position": {
        "line_start": 53,
        "line_end": 56,
        "col_start": 1,
        "col_end": 17
      },
      "references": [],
      "proof": null
    },
    {
      "id": "theorem-3-a44f26",
      "type": "theorem",
      "content": "\\label{thm:main}\nLet $\\F$ be a $(1-\\eps)$-approximate union closed set system, where $\\eps < 1/2$. Then there is an element which is contained in a $\\psi-\\delta$ fraction of sets in $\\F$, where $\\delta=2 \\eps \\left( 1 + \\frac{\\log(1/\\eps)}{\\log |\\F|} \\right)$.",
      "content_preview": "\\\\label{thm:main}<br>Let $\\\\F$ be a $(1-\\\\eps)$-approximate union closed set system, where $\\\\eps < 1/2$. Then there is an element which is contained in a $\\\\psi-\\\\delta$ fraction of sets in $\\\\F$, where $\\\\delta=2 \\\\eps \\\\left( 1 +...",
      "prerequisites_preview": "<b>union closed</b>: A set system is called union closed if for any two sets in the set system their union is also in the set system. A set system $\\\\F$ is \\\\emph{union closed} if for all $A,B \\\\in \\\\F$ we have $A \\\\cup B \\\\in \\\\F$.<br><br><b>$\\\\delta$</b>: where $\\\\delta=2 \\\\eps \\\\left( 1 + \\\\frac{\\\\log(1/\\\\eps)}{\\\\log |\\\\F|} \\\\right)$.<br><br><b>$\\\\psi$</b>: Gilmer conjectured that his technique can be sharpened to give the constant $\\\\psi := \\\\frac{3-\\\\sqrt{5}}{2} \\\\approx 0.38$.",
      "display_name": "Theorem",
      "label": "thm:main",
      "position": {
        "line_start": 60,
        "line_end": 63,
        "col_start": 1,
        "col_end": 14
      },
      "references": [
        {
          "target_id": "h_union",
          "reference_type": "internal",
          "context": ",B \\in \\F$ be uniformly and independently chosen. \\Cref{h_union} then gives $$ H(A \\cup B) \\ge \\frac{p}{ 2\\varphi}",
          "position": {
            "line_start": 14,
            "line_end": 14,
            "col_start": 9,
            "col_end": 23
          }
        }
      ],
      "proof": "Let $\\F$ be a $(1-\\eps)$-approximate union closed family over $[n]$. Let $p=\\min_{i \\in [n]} \\Pr_{A \\in \\F}[A_i=0]$, where our goal is to lower bound $1-p$. Let $A,B \\in \\F$ be uniformly and independently chosen. \\Cref{h_union} then gives\n$$\nH(A \\cup B) \\ge \\frac{p}{ 2\\varphi} \\Big(H(A)+H(B)\\Big) = \\frac{p}{\\varphi} \\log |\\F|.\n$$\nNext we show that $H(A \\cup B)$ cannot be much larger than $\\log |\\F|$. Let $I$ be the indicator for the event $A \\cup B \\in \\F$, where by assumption $\\Pr[I=1]\\ge 1-\\eps$. Then\n$$\nH(A \\cup B) \\le H(A \\cup B, I) = H(I) + H(A \\cup B|I=0) \\Pr[I=0] + H(A \\cup B|I=1) \\Pr[I=1].\n$$\nWe bound the terms one by one. \nFirst, since $I$ is binary and $\\Pr[I=0]\\le \\eps <1/2$ we have $H(I) \\le h(\\eps) \\le 2 \\eps \\log(1/\\eps)$. Next, when $I=0$, we use the naive bound $H(A \\cup B|I=0) \\le H(A,B|I=0) \\le 2 \\log |\\F|$. Finally, when $I=1$ we have that $A \\cup B|I=1$ is a distribution supported on $\\F$ and so $H(A \\cup B|I=1) \\le \\log |\\F|$. Putting these together gives\n$$\n\\frac{p}{\\varphi} \\log|\\F| \\le H(A \\cup B) \\le 2 \\eps \\log(1/\\eps) + (1+2 \\eps) \\log|\\F|.\n$$\nWe thus obtain\n$$\n1-p \\ge 1-\\varphi-2\\eps \\left(1+\\frac{ \\log(1/\\eps)}{\\log|\\F|}\\right).\n$$\nThe proof follows, as $1-\\varphi=\\frac{3-\\sqrt{5}}{2} = \\psi$."
    },
    {
      "id": "example-4-15984f",
      "type": "example",
      "content": "Let $n$ be large enough, and define the following set systems over $[n]$:\n$$\n\\F_1 = \\{x \\in \\{0,1\\}^n: |x|=\\psi n + n^{2/3}\\}, \\qquad\n\\F_2 = \\{x \\in \\{0,1\\}^n: |x| \\ge (1-\\psi) n\\}, \\qquad\n\\F=\\F_1 \\cup \\F_2.\n$$\nOne can verify that: (i) $\\F$ is $1-o(1)$ approximate union closed (using the fact that $1-\\psi = 2\\psi-\\psi^2$); (ii) that $|\\F_2| = o( |\\F_1|)$; and (iii) that hence each element $i \\in [n]$ is in at most $\\psi+o(1)$ fraction of sets in $\\F$.",
      "content_preview": "Let $n$ be large enough, and define the following set systems over $[n]$:<br>$$<br>\\\\F_1 = \\\\{x \\\\in \\\\{0,1\\\\}^n: |x|=\\\\psi n + n^{2/3}\\\\}, \\\\qquad<br>\\\\F_2 = \\\\{x \\\\in \\\\{0,1\\\\}^n: |x| \\\\ge (1-\\\\psi) n\\\\}, \\\\qquad<br>\\\\F=\\\\F_1 \\\\cup...",
      "prerequisites_preview": "<b>union closed</b>: A set system is called union closed if for any two sets in the set system their union is also in the set system. A set system $\\\\F$ is \\\\emph{union closed} if for all $A,B \\\\in \\\\F$ we have $A \\\\cup B \\\\in \\\\F$.<br><br><b>$\\\\psi$</b>: Gilmer conjectured that his technique can be sharpened to give the constant $\\\\psi := \\\\frac{3-\\\\sqrt{5}}{2} \\\\approx 0.38$.<br><br><b>$\\\\F_1$</b>: Let $n$ be large enough, and define the following set systems over $[n]$:<br>$$<br>\\\\F_1 = \\\\{x \\\\in \\\\{0,1\\\\}^n: |x|=\\\\psi n + n^{2/3}\\\\}, \\\\qquad<br>\\\\F_2 = \\\\{x \\\\in \\\\{0,1\\\\}^n: |x| \\\\ge (1-\\\\psi) n\\\\}, \\\\qquad<br>\\\\F=\\\\F_1 \\\\cup \\\\F_2.<br>$$<br><br><b>$\\\\F_2$</b>: \\\\F_2 = \\\\{x \\\\in \\\\{0,1\\\\}^n: |x| \\\\ge (1-\\\\psi) n\\\\}",
      "display_name": "Example",
      "label": null,
      "position": {
        "line_start": 67,
        "line_end": 75,
        "col_start": 1,
        "col_end": 14
      },
      "references": [],
      "proof": null
    },
    {
      "id": "claim-5-854419",
      "type": "claim",
      "content": "\\label{h_frac_min}\nThe minimum of $\\frac{h(x^2)}{x h(x)}$ for $x \\in [0,1]$ is obtained at $x=\\varphi$.",
      "content_preview": "\\\\label{h_frac_min}<br>The minimum of $\\\\frac{h(x^2)}{x h(x)}$ for $x \\\\in [0,1]$ is obtained at $x=\\\\varphi$.",
      "prerequisites_preview": "<b>$h(x)$</b>: Let $h(x) = -(x \\\\log x + (1-x) \\\\log (1-x))$ be the binary entropy function.",
      "display_name": "Claim",
      "label": "h_frac_min",
      "position": {
        "line_start": 85,
        "line_end": 88,
        "col_start": 1,
        "col_end": 12
      },
      "references": [],
      "proof": null
    },
    {
      "id": "claim-6-2251be",
      "type": "claim",
      "content": "\\label{f_min}\nThe function $f$ is minimized at $(\\varphi,\\varphi)$. At this point $f(\\varphi,\\varphi)=\\frac{1}{2 \\varphi}$.",
      "content_preview": "\\\\label{f_min}<br>The function $f$ is minimized at $(\\\\varphi,\\\\varphi)$. At this point $f(\\\\varphi,\\\\varphi)=\\\\frac{1}{2 \\\\varphi}$.",
      "prerequisites_preview": "<b>$\\\\varphi$</b>: Let $\\\\varphi = 1-\\\\psi =\\\\frac{\\\\sqrt{5}-1}{2}$ be the positive root of $x^2+x-1=0$.<br><br><b>$f$</b>: Let $f:[0,1]^2 \\\\to \\\\mathbb{R}_{\\\\ge 0}$ be defined as<br>$$<br>f(x,y) := \\\\frac{h(xy)}{h(x)y + h(y)x}<br>$$<br>for $(x,y) \\\\in (0,1)^2$ and extended (continuously) to $[0,1]^2$ by setting $f(x,y) = 1$ if $x \\\\in \\\\{0,1\\\\}$ or $y \\\\in \\\\{0,1\\\\}$.",
      "display_name": "Claim",
      "label": "f_min",
      "position": {
        "line_start": 98,
        "line_end": 101,
        "col_start": 1,
        "col_end": 12
      },
      "references": [
        {
          "target_id": "h_frac_min",
          "reference_type": "internal",
          "context": "y$, we have $$ f(x,x) = \\frac{h(x^2)}{2xh(x)}. $$ \\Cref{h_frac_min} gives that $f(x,x)$ is minimized at $x=\\varphi$.",
          "position": {
            "line_start": 34,
            "line_end": 38,
            "col_start": 15,
            "col_end": 2
          }
        }
      ],
      "proof": "First, by routine calculations one can verify that $f$ is indeed continuous on $[0,1]^2$ and that $f(x,y)<1$ for $(x,y) \\in (0,1)^2$. Thus, the minimum of $f$ is attained in $(0,1)^2$. Next, let $g(x)=\\frac{h(x)}{x}$, which is defined on $(0,1)$, and note that\n$$\nf(x,y) = \\frac{g(xy)}{g(x)+g(y)}.\n$$\n\nWe first show that $f$ is minimized on the diagonal, namely at some point $(x,x)$. Assume that $f$ is minimized at some point $(x^*,y^*)$, and let $\\alpha = f(x^*,y^*)$. Define \n$$\nF(x,y) = g(xy) - \\alpha (g(x)+g(y)).\n$$\nThen $F(x,y) \\ge 0$ for all $x,y \\in (0,1)^2$ and $F(x^*, y^*)=0$. \nThus the partial derivatives of $F$ must be zero at the minimum point:\n$$\n\\frac{\\partial F}{\\partial x}(x^*,y^*)=\\frac{\\partial F}{\\partial y}(x^*,y^*)=0.\n$$\nEvaluating the derivatives gives\n$$\n\\frac{\\partial F}{\\partial x}(x,y) = g'(xy) \\cdot y - \\alpha g'(x), \\qquad\n\\frac{\\partial F}{\\partial y}(x,y) = g'(xy) \\cdot x - \\alpha g'(y).\n$$\nDefine $G(x)=x g'(x)$ and note that we obtained that $G(x^*)=G(y^*)$. A direct calculation gives $g'(x) = \\frac{\\log(1-x)}{x^2}$, which implies that $G$ is monotonically decreasing, and so we must have $x^*=y^*$.\n\nFinally, restricting to $x=y$, we have\n$$\nf(x,x) = \\frac{h(x^2)}{2xh(x)}.\n$$\n\\Cref{h_frac_min} gives that $f(x,x)$ is minimized at $x=\\varphi$. Since $\\varphi^2 = 1- \\varphi$ we have $h(\\varphi^2)=h(\\varphi)$ and hence\n$$\nf(\\varphi, \\varphi)=\\frac{1}{2 \\varphi}.\n$$"
    },
    {
      "id": "corollary-7-79744a",
      "type": "corollary",
      "content": "\\label{h_analytic}\nFor $x,y \\in [0,1]$ we have\n$$\nh(xy) \\ge \\frac{1}{2 \\varphi} \\Big(x h(y) + y h(x) \\Big).\n$$",
      "content_preview": "\\\\label{h_analytic}<br>For $x,y \\\\in [0,1]$ we have<br>$$<br>h(xy) \\\\ge \\\\frac{1}{2 \\\\varphi} \\\\Big(x h(y) + y h(x) \\\\Big).<br>$$",
      "prerequisites_preview": "<b>$h(x)$</b>: Let $h(x) = -(x \\\\log x + (1-x) \\\\log (1-x))$ be the binary entropy function.<br><br><b>$\\\\varphi$</b>: Let $\\\\varphi = 1-\\\\psi =\\\\frac{\\\\sqrt{5}-1}{2}$ be the positive root of $x^2+x-1=0$.",
      "display_name": "Corollary",
      "label": "h_analytic",
      "position": {
        "line_start": 135,
        "line_end": 141,
        "col_start": 1,
        "col_end": 16
      },
      "references": [],
      "proof": null
    },
    {
      "id": "claim-8-eba7f5",
      "type": "claim",
      "content": "\\label{h_union}\nLet $A,B$ be two independent random variables taking values in $\\{0,1\\}^n$. Assume for all $i \\in [n]$ that $\\Pr[A_i=0] \\ge p$ and $\\Pr[B_i=0] \\ge p$. Then \n$$\nH(A \\cup B) \\ge \\frac{p}{2 \\varphi}\\Big( H(A)+H(B)\\Big).\n$$",
      "content_preview": "\\\\label{h_union}<br>Let $A,B$ be two independent random variables taking values in $\\\\{0,1\\\\}^n$. Assume for all $i \\\\in [n]$ that $\\\\Pr[A_i=0] \\\\ge p$ and $\\\\Pr[B_i=0] \\\\ge p$. Then <br>$$<br>H(A \\\\cup B) \\\\ge \\\\frac{p}{2 \\\\varphi}\\\\Big(...",
      "prerequisites_preview": "<b>$\\\\varphi$</b>: Let $\\\\varphi = 1-\\\\psi =\\\\frac{\\\\sqrt{5}-1}{2}$ be the positive root of $x^2+x-1=0$.",
      "display_name": "Claim",
      "label": "h_union",
      "position": {
        "line_start": 145,
        "line_end": 151,
        "col_start": 1,
        "col_end": 12
      },
      "references": [
        {
          "target_id": "h_analytic",
          "reference_type": "internal",
          "context": "}=x]$ and $q(y) = \\Pr[B_i=0 | B_{<i}=y]$. Then by \\Cref{h_analytic} $$ H\\Big(A_i \\cup B_i | A_{<i}=x, B_{<i}=y\\Big) =",
          "position": {
            "line_start": 15,
            "line_end": 15,
            "col_start": 14,
            "col_end": 31
          }
        }
      ],
      "proof": "The chain rule and data processing inequality yield\n$$\nH(A \\cup B) = \\sum_{i \\in [n]} H(A_i \\cup B_i | (A \\cup B)_{<i}) \\ge \\sum_{i \\in [n]} H(A_i \\cup B_i | A_{<i}, B_{<i}).\n$$\nLet $p(x) = \\Pr[A_i=0 | A_{<i}=x]$ and $q(y) = \\Pr[B_i=0 | B_{<i}=y]$. Then by \\Cref{h_analytic}\n$$\nH\\Big(A_i \\cup B_i | A_{<i}=x, B_{<i}=y\\Big) = h\\Big(p(x) q(y)\\Big) \\ge \\frac{1}{2 \\varphi} \\Big( p(x) h(q(y)) + q(y) h(p(x)) \\Big).\n$$\nAveraging over $A_{<i}, B_{<i}$ which are independent gives\n\\begin{align*}\nH(A_i \\cup B_i | A_{<i}, B_{<i}) \n&\\ge \\frac{1}{2 \\varphi} \\Big( \\E_{A_{<i}} [ p(A_{<i})] \\cdot \\E_{B_{<i}}[h(q(B_{<i}))] +    \\E_{B_{<i}} [q(B_{<i})] \\cdot \\E_{A_{<i}}[h(p(A_{<i}))]\\Big)\\\\\n&=\\frac{1}{2 \\varphi} \\Big( \\Pr[A_i=0] \\cdot H(B_i|B_{<i}) + \\Pr[B_i=0] \\cdot H(A_i|A_{<i})\\Big).\n\\end{align*}\nUsing the assumption that $\\Pr[A_i=0] \\ge p$ and $\\Pr[B_i=0] \\ge p$ gives\n$$\nH(A_i \\cup B_i) \\ge \\frac{p}{2 \\varphi} \\Big( H(A_i|A_{<i}) + H(B_i|B_{<i})\\Big).\n$$\nThe claim follows by summing over $i \\in [n]$."
    }
  ],
  "edges": [
    {
      "source": "theorem-3-a44f26",
      "target": "claim-8-eba7f5",
      "context": ",B \\in \\F$ be uniformly and independently chosen. \\Cref{h_union} then gives $$ H(A \\cup B) \\ge \\frac{p}{ 2\\varphi}",
      "reference_type": "internal",
      "dependency_type": null,
      "dependency": null,
      "type": "internal"
    },
    {
      "source": "claim-6-2251be",
      "target": "claim-5-854419",
      "context": "y$, we have $$ f(x,x) = \\frac{h(x^2)}{2xh(x)}. $$ \\Cref{h_frac_min} gives that $f(x,x)$ is minimized at $x=\\varphi$.",
      "reference_type": "internal",
      "dependency_type": null,
      "dependency": null,
      "type": "internal"
    },
    {
      "source": "claim-8-eba7f5",
      "target": "corollary-7-79744a",
      "context": "}=x]$ and $q(y) = \\Pr[B_i=0 | B_{<i}=y]$. Then by \\Cref{h_analytic} $$ H\\Big(A_i \\cup B_i | A_{<i}=x, B_{<i}=y\\Big) =",
      "reference_type": "internal",
      "dependency_type": null,
      "dependency": null,
      "type": "internal"
    },
    {
      "source": "example-4-15984f",
      "target": "theorem-3-a44f26",
      "context": null,
      "reference_type": null,
      "dependency_type": "provides_example",
      "dependency": "The Source explicitly constructs a family F and states that \u201c(i) \\F is 1-o(1) approximate union closed\u201d and \u201c(iii) hence each element i \\in [n] is in at most \\psi+o(1) fraction of sets in \\F.\u201d The Target (Thm \\ref{thm:main}) asserts that any (1-\\eps)-approximate union closed family (with \\eps=o(1)) contains an element in about \\psi-\\delta = \\psi-o(1) fraction of sets. The Source therefore provides a concrete example of an approximate union-closed family whose element-frequencies are at most \\psi+o(1), demonstrating the theorem's bound is (asymptotically) tight. Quoted source phrases: \u201c\\F is 1-o(1) approximate union closed\u201d and \u201ceach element i \\in [n] is in at most \\psi+o(1) fraction of sets in \\F.\u201d",
      "type": "provides_example"
    },
    {
      "source": "corollary-7-79744a",
      "target": "claim-5-854419",
      "context": null,
      "reference_type": null,
      "dependency_type": "uses_result",
      "dependency": "The corollary displays the constant 1/(2\\varphi) in the inequality \u201ch(xy) \\ge \\frac{1}{2 \\varphi} \\Big(x h(y) + y h(x) \\Big).\u201d This constant evidently comes from the extremal location of the ratio used to bound such bilinear expressions; the Target states \u201cThe minimum of \\frac{h(x^2)}{x h(x)} for x \\in [0,1] is obtained at x=\\varphi.\u201d Thus the corollary is using the Target result (the minimum is attained at x=\\varphi) to fix the numeric prefactor 1/(2\\varphi) in the inequality.",
      "type": "uses_result"
    },
    {
      "source": "example-4-15984f",
      "target": "definition-1-b20d1f",
      "context": null,
      "reference_type": null,
      "dependency_type": "uses_definition",
      "dependency": "The Source states that \u201c\\F is $1-o(1)$ approximate union closed\u2026\u201d, directly invoking the concept of (approximate) union-closedness. The Target provides the formal definition \u201cA set system \\F is union closed if for all $A,B \\in \\F$ we have $A \\cup B \\in \\F$,\u201d which the Source builds on when claiming approximate union-closedness.",
      "type": "uses_definition"
    },
    {
      "source": "example-4-15984f",
      "target": "definition-2-8354c3",
      "context": null,
      "reference_type": null,
      "dependency_type": "uses_definition",
      "dependency": "The Source explicitly applies the notion defined in the Target: it states \"One can verify that: (i) \\F is 1-o(1) approximate union closed\", which directly uses the Target's definition of a \"c-approximate union closed\" set system (here with c = 1-o(1)).",
      "type": "uses_definition"
    },
    {
      "source": "claim-8-eba7f5",
      "target": "claim-6-2251be",
      "context": null,
      "reference_type": null,
      "dependency_type": "uses_result",
      "dependency": "The Source uses the inequality\n\"h(p(x) q(y)) \\ge \\frac{1}{2 \\varphi} \\Big( p(x) h(q(y)) + q(y) h(p(x)) \\Big)\".\nWith g(x)=h(x)/x and f(x,y)=g(xy)/(g(x)+g(y)), the Target claim f_min (which states f is minimized at (\\varphi,\\varphi) with minimum 1/(2\\varphi)) is exactly the result f(x,y) \\ge 1/(2\\varphi) for all x,y. Rearranging f(x,y) \\ge 1/(2\\varphi) gives g(xy) \\ge (1/(2\\varphi))(g(x)+g(y)), and multiplying by xy yields\nh(xy) \\ge \\frac{1}{2\\varphi}\\big(x h(y)+y h(x)\\big),\nwhich is the inequality the Source invokes. Thus the Source directly applies the Target's result.",
      "type": "uses_result"
    },
    {
      "source": "theorem-3-a44f26",
      "target": "definition-1-b20d1f",
      "context": null,
      "reference_type": null,
      "dependency_type": "uses_definition",
      "dependency": "The Source explicitly builds on the union-closed notion: \"Let \\F be a $(1-\\eps)$-approximate union closed family\" and it refers to the membership condition \"Let I be the indicator for the event $A \\cup B \\in \\F$, where by assumption $\\Pr[I=1]\\ge 1-\\eps$.\" These use the Target's definition that a set system is union closed iff for all $A,B\\in\\F$ we have $A\\cup B\\in\\F$ (here in an approximate/probabilistic form).",
      "type": "uses_definition"
    },
    {
      "source": "theorem-3-a44f26",
      "target": "definition-2-8354c3",
      "context": null,
      "reference_type": null,
      "dependency_type": "uses_definition",
      "dependency": "The Source begins by assuming \u201cLet \\F be a (1-\\eps)-approximate union closed family...\u201d and later uses this meaning explicitly: \u201cLet I be the indicator for the event A \\cup B \\in \\F, where by assumption \\Pr[I=1]\\ge 1-\\eps.\u201d These phrases show the theorem relies on the Target's definition that a c-approximate union closed family has at least a c-fraction of pairs A,B with A\\cup B\\in\\F.",
      "type": "uses_definition"
    },
    {
      "source": "corollary-7-79744a",
      "target": "claim-6-2251be",
      "context": null,
      "reference_type": null,
      "dependency_type": "is_corollary_of",
      "dependency": "The Target states: \"The function $f$ is minimized at $(\\varphi,\\varphi)$. At this point $f(\\varphi,\\varphi)=\\frac{1}{2 \\varphi}$.\" and in its proof defines \"g(x)=\\frac{h(x)}{x}, ... note that\n$$\nf(x,y) = \\frac{g(xy)}{g(x)+g(y)}.\n$$\n\". Since g(x)=h(x)/x, one gets f(x,y)=h(xy)/(x h(y)+y h(x)), so the Target implies f(x,y)\\ge f(\\varphi,\\varphi)=1/(2\\varphi) for all x,y. Rearranging yields exactly the Source inequality \"h(xy) \\ge \\frac{1}{2 \\varphi} \\Big(x h(y) + y h(x) \\Big).\" Thus the Source is a direct corollary of the Target.",
      "type": "is_corollary_of"
    },
    {
      "source": "definition-2-8354c3",
      "target": "definition-1-b20d1f",
      "context": null,
      "reference_type": null,
      "dependency_type": "is_generalization_of",
      "dependency": "The Source defines: \"A set system F is c-approximate union closed if for at least a c-fraction of the pairs A,B \u2208 F we have A \u222a B \u2208 F.\" Taking c = 1 gives the condition \"for at least a 1-fraction of the pairs ...\" i.e. for all pairs, which matches the Target definition: \"A set system F is union closed if for all A,B \u2208 F we have A \u222a B \u2208 F.\" Hence the Source is a generalization (a relaxed/parametrized version) of the Target definition.",
      "type": "is_generalization_of"
    }
  ]
};
        const nodeTypes = [...new Set(graphData.nodes.map(d => d.type))];
        const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
        const nodeColors = nodeTypes.reduce((acc, type) => {
            acc[type] = colorScale(type);
            return acc;
        }, {});

        const svg = d3.select("#graph");
        const width = svg.node().getBoundingClientRect().width;
        const height = svg.node().getBoundingClientRect().height;

        svg.append("defs").append("marker")
            .attr("id", "arrowhead").attr("viewBox", "-0 -5 10 10").attr("refX", 25)
            .attr("refY", 0).attr("orient", "auto").attr("markerWidth", 8).attr("markerHeight", 8)
            .append("path").attr("d", "M0,-5L10,0L0,5").attr("fill", "#999");

        const zoom = d3.zoom().scaleExtent([0.1, 5]).on("zoom", (event) => g.attr("transform", event.transform));
        svg.call(zoom);
        const g = svg.append("g");

        svg.on("click", () => {
            if (pinned) {
                pinned = false;
                pinnedNode = null;
                tooltip.style("display", "none");
            }
        });

        const simulation = d3.forceSimulation(graphData.nodes)
            .force("link", d3.forceLink(graphData.edges).id(d => d.id).distance(120))
            .force("charge", d3.forceManyBody().strength(-500))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(30));

        const link = g.append("g").selectAll("line")
            .data(graphData.edges).enter().append("line").attr("class", "link");

        const node = g.append("g").selectAll("circle")
            .data(graphData.nodes).enter().append("circle").attr("class", "node")
            .attr("r", 15).attr("fill", d => nodeColors[d.type] || '#ccc')
            .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));

        const label = g.append("g").selectAll("text")
            .data(graphData.nodes).enter().append("text").attr("class", "node-label")
            .attr("dy", 28).text(d => d.display_name);

        const tooltip = d3.select("#tooltip");
        let pinned = false;
        let pinnedNode = null;

        // Helper function to clean LaTeX content for proper display
        function cleanLatexForDisplay(content) {
            if (!content) return '';

            return content
                // Remove LaTeX labels
                .replace(/\\label\{[^}]*\}/g, '')
                // Remove section commands
                .replace(/\\(sub)?(sub)?section\*?\{[^}]*\}/g, '')
                // Remove document structure commands
                .replace(/\\(chapter|part|paragraph|subparagraph)\*?\{[^}]*\}/g, '')
                // Remove \title, \author, \date commands
                .replace(/\\(title|author|date|maketitle)\*?\{[^}]*\}/g, '')
                .replace(/\\maketitle/g, '')
                // Remove comments (but not escaped %)
                .replace(/(?<!\\)%.*$/gm, '')
                // Remove \usepackage, \documentclass, etc.
                .replace(/\\(usepackage|documentclass|begin\{document\}|end\{document\}).*$/gm, '')
                // Normalize excessive whitespace
                .replace(/\n{3,}/g, '\n\n')
                .trim();
        }

        // Helper to check if content already has math delimiters
        function needsMathDelimiters(content) {
            if (!content) return false;
            const trimmed = content.trim();
            // Check if already wrapped in display math
            if (trimmed.startsWith('$$') || trimmed.startsWith('\\[')) return false;
            // Check if it's an equation environment (these don't need extra delimiters)
            if (trimmed.startsWith('\\begin{equation') ||
                trimmed.startsWith('\\begin{align') ||
                trimmed.startsWith('\\begin{gather')) return false;
            return true;
        }

        function renderNodeTooltip(event, d) {
            // 1. Clean and prepare content first
            const rawPreview = d.content_preview || '';
            const cleanedPreview = cleanLatexForDisplay(rawPreview);
            const finalPreview = needsMathDelimiters(cleanedPreview)
                ? `$${cleanedPreview}$`
                : cleanedPreview;

            let prereqsHtml = '';
            if (d.prerequisites_preview) {
                const rawPrereqs = d.prerequisites_preview || '';
                const cleanedPrereqs = cleanLatexForDisplay(rawPrereqs);
                const finalPrereqs = needsMathDelimiters(cleanedPrereqs)
                    ? `$${cleanedPrereqs}$`
                    : cleanedPrereqs;
                prereqsHtml = `<h4>Prerequisites</h4><div class="math-content">${finalPrereqs}</div>`;
            }

            // 2. Set complete HTML with math content included
            tooltip
                .style("display", "block")
                .html(`<h4>${d.display_name}</h4>
                       <p><span class="id-label">ID: ${d.id} | Label: ${d.label || 'N/A'}</span></p>
                       <div><strong>Preview:</strong></div>
                       <div class="math-content">${finalPreview}</div>
                       ${prereqsHtml}`)
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 28) + "px");

            // 3. Trigger MathJax to typeset the content of the tooltip
            if (window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetPromise([tooltip.node()]).catch(err => {
                    console.error('MathJax typesetting failed:', err);
                });
            }
        }

        function hideTooltipIfNotPinned() {
            if (!pinned) {
                tooltip.style("display", "none");
            }
        }

        node
            .on("mouseover", (event, d) => {
                if (pinned) return;
                renderNodeTooltip(event, d);
            })
            .on("mouseout", () => {
                hideTooltipIfNotPinned();
            })
            .on("click", (event, d) => {
                event.stopPropagation();
                pinned = true;
                pinnedNode = d;
                renderNodeTooltip(event, d);
            });

        link.on("mouseover", (event, d) => {
            if (pinned) return;
            const dependencyType = (d.type || 'DEPENDS ON').replace(/_/g, ' ').toUpperCase();

            // 1. Clean and prepare content
            const rawDependency = d.dependency || 'N/A';
            const cleanedDependency = cleanLatexForDisplay(rawDependency);
            const finalDependency = needsMathDelimiters(cleanedDependency)
                ? `$${cleanedDependency}$`
                : cleanedDependency;

            // 2. Set complete HTML with math content
            tooltip.style("display", "block")
                .html(`<h4>Dependency Link</h4>
                       <p>${d.source.display_name} <br>
                          <span class="edge-type">‚Üí ${dependencyType} ‚Üí</span> <br>
                          ${d.target.display_name}</p>
                       <p><strong>Justification:</strong></p>
                       <div class="math-content">${finalDependency}</div>`)
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 28) + "px");

            // 3. Trigger MathJax
            if (window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetPromise([tooltip.node()]).catch(err => {
                    console.error('MathJax typesetting failed:', err);
                });
            }
        }).on("mouseout", () => {
            hideTooltipIfNotPinned();
        });

        simulation.on("tick", () => {
            link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
            node.attr("cx", d => d.x).attr("cy", d => d.y);
            label.attr("x", d => d.x).attr("y", d => d.y);
        });

        const legendContainer = d3.select("#legend-container");
        nodeTypes.forEach(type => {
            const item = legendContainer.append("div").attr("class", "legend-item");
            item.append("div").attr("class", "legend-color").style("background-color", nodeColors[type]);
            item.append("span").text(type.charAt(0).toUpperCase() + type.slice(1));
        });

        let isPlaying = true;
        d3.select("#play-pause").on("click", () => {
            if (isPlaying) {
                simulation.stop();
                d3.select("#play-pause").text("‚ñ∂Ô∏è Play");
            } else {
                simulation.alpha(0.3).restart();
                d3.select("#play-pause").text("‚è∏Ô∏è Pause");
            }
            isPlaying = !isPlaying;
        });
        d3.select("#reset").on("click", () => {
            simulation.alpha(1).restart();
            if (!isPlaying) { d3.select("#play-pause").dispatch('click'); }
        });
        d3.select("#center").on("click", () => svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity));

        function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
        function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
        function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }
    </script>
</body>
</html>

<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Paper Artifact Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        :root {
            --bg: #0f1216;
            --panel: #161b22;
            --text: #c9d1d9;
            --muted: #8b949e;
            --accent: #58a6ff;
            --border: #30363d;
        }

        html,
        body {
            margin: 0;
            height: 100%;
            background: var(--bg);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", Arial, sans-serif
        }

        .wrap {
            max-width: 1100px;
            margin: 0 auto;
            padding: 14px
        }

        .top {
            display: flex;
            gap: 10px;
            align-items: center
        }

        label {
            font-size: 12px;
            color: var(--muted)
        }

        select {
            background: #0d1117;
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px 10px
        }

        h1 {
            margin: 14px 0 8px;
            text-align: center;
            font-size: 24px;
            font-weight: 700
        }

        .card {
            margin: 12px auto;
            border: 1px solid var(--border);
            border-radius: 10px;
            background: var(--panel);
            padding: 12px;
            max-width: 900px;
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 12px;
            align-items: center
        }

        .arrow {
            width: 28px;
            height: 28px;
            display: grid;
            place-items: center;
            border: 1px solid var(--border);
            border-radius: 999px;
            background: #0d1117;
            cursor: pointer;
            color: var(--text)
        }

        .arrow:hover {
            background: #151922
        }

        .snippet {
            max-height: 140px;
            overflow: auto;
            white-space: pre-wrap;
            font-size: 13px;
            line-height: 1.35;
            color: #d0d7de
        }

        .muted {
            color: var(--muted);
            font-size: 12px
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 14px;
            max-width: 1000px;
            margin: 12px auto
        }

        .cell {
            border: 1px solid var(--border);
            border-radius: 10px;
            background: var(--panel);
            padding: 12px;
            min-height: 120px
        }

        .cell h3 {
            margin: 0 0 8px;
            font-size: 14px;
            color: var(--muted);
            font-weight: 600
        }

        ul {
            margin: 0;
            padding-left: 18px
        }

        li {
            margin: 6px 0
        }

        .pill {
            display: inline-block;
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 2px 8px;
            font-size: 11px;
            color: var(--muted)
        }

        .meta {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 4px
        }

        /* KaTeX on dark theme */
        .katex {
            color: var(--text);
        }

        .katex-display {
            margin: 8px 0;
        }

        .snippet .katex {
            white-space: normal;
        }

        /* Per-query side-by-side rows */
        .rows {
            display: block;
        }

        .row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 14px;
            border-top: 1px solid var(--border);
            padding: 10px 0;
        }

        .row.header {
            border-top: none;
            padding-top: 0;
        }

        .row .col {
            min-width: 0;
        }

        .row .col ul {
            margin: 0;
            padding-left: 18px;
        }

        .row .col li {
            margin: 6px 0;
        }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
</head>

<body>
    <div class="wrap">
        <div class="top">
            <div>
                <label for="paperSelect">Paper</label><br>
                <select id="paperSelect"></select>
            </div>
            <div class="muted" style="margin-left:auto">
                <span id="dataSource">Data: —</span>
            </div>
        </div>

        <h1 id="paperTitle">—</h1>

        <div class="card">
            <div id="btnPrev" class="arrow" title="Previous">
                <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor" aria-hidden="true">
                    <path d="M15.41 7.41 14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path>
                </svg>
            </div>
            <div>
                <div class="meta">
                    <span id="artifactIndex" class="pill">Artifact —</span>
                    <span id="artifactCount" class="pill">—</span>
                </div>
                <div id="artifactText" class="snippet"></div>
            </div>
            <div id="btnNext" class="arrow" title="Next">
                <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor" aria-hidden="true">
                    <path d="M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6z"></path>
                </svg>
            </div>
        </div>

        <div class="grid">
            <div class="cell" style="grid-column: 1 / -1;">
                <div class="rows">
                    <div class="row header">
                        <div class="col col-q">
                            <h3>Generated Queries</h3>
                        </div>
                        <div class="col col-r">
                            <h3>Candidate References</h3>
                        </div>
                    </div>
                    <div id="queryRows"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Embedded CSV: full content from detailed_log.csv -->
    <script type="text/csv" id="embedded-csv">
arxiv_id,bucket,artifact_id,artifact_text,query,category,predicted_candidates,is_in_top_k,rank_if_found
1901.02208v1,older,theorem-1-c01898,"\label{Theo_XuJerbi}
Assume that $\XR$ is separable and that $\AR$ satisfies Assumption \ref{ass_EXPStab}.
Assume moreover that~:
\begin{enumerate}
\item the operator $\BR$ is bounded;
\item the operator $\CR$ is $\AR$-admissible (see \cite{tucsnak2009observation}), i.e.
\begin{itemize}
\item it is $\AR$-bounded~:
\begin{equation}\label{eq_ABounded}
|\CR \varphi| \leqslant   c(\|\varphi\|_\XR + \|\AR \varphi\|_\XR)\ ,\ \forall \ \varphi\in D(\AR),
\end{equation}
for some positive real number $c$;
\item  there exist $T>0$ and $c_T>0$ such that
$$
\int_0^T |\CR e^{\AR t}\varphi|^2dt \leqslant    c_T^2 \|\varphi\|_\XR^2\ ,\ \forall \ \varphi\in D(\AR);
$$
\end{itemize}
\item the rank condition holds. In other words operators $\AR$, $\BR$ and  $\CR$ satisfy
\begin{equation}\label{eq_RankCondition}
\texttt{rank}\{\CR \AR^{-1}\BR\} = m;
\end{equation}
\end{enumerate}
then there exists  a positive real number $k_i^*$ and a $m\times m$ matrix $K_i$, such that for all $0<k_i<   k_i^* $ the operator $\AR_e$ given in \eqref{def_Ae}
is the generator of an exponentially stable $C_0$-semigroup in the extended state space $\XR_e$. More precisely, the system (\ref{eq_AbsCauchyProblem}) in closed loop with (\ref{eq_ControlInte}) is well-posed and the equilibrium is exponentially stable. Moreover,  for all $w$ and $y_{ref}$, equation \eqref{eq_RegulDef} holds (i.e the regulation is achieved).","Existence of small integral gain for exponential stabilization and regulation on a separable Banach space K: let K be separable, A generate an exponentially stable C_0-semigroup, B bounded, C A-bounded in the sense |C\varphi| \le c(\|\varphi\|_K + \|A\varphi\|_K) for all \varphi\in D(A), and assume rank\{C A^{-1} B\}=m. Is there k_i^*>0 and an m\times m matrix K_i such that for all 0<k_i<k_i^* the closed-loop extended operator A_e generates an exponentially stable C_0-semigroup on the extended state space K_e and the regulation (output tracking) is achieved?",imperfect_recall,"[{'reference': {'title': 'Internal model based controller design for robust output regulation of regular linear systems'}, 'confidence': 0.88, 'reasoning': 'This SIAM J. Control Optim. style paper by Paunonen & Pohjolainen develops internal-model-based controllers for regular (well-posed) infinite-dimensional linear systems and gives explicit controller constructions that achieve robust regulation while preserving exponential stability — directly relevant to questions about integral-action gains and closed-loop generator stability on extended state spaces.'}, {'reference': {'title': 'The internal model principle of control theory'}, 'confidence': 0.78, 'reasoning': 'The classical Francis–Wonham internal model principle underpins why integral (or internal-model) action is needed for exact regulation and explains structural rank conditions like rank{C A^{-1} B}=m. Any infinite-dimensional extension or small-gain result for integral controllers is built on these ideas.'}, {'reference': {'title': 'Robust regulation of infinite-dimensional systems'}, 'confidence': 0.68, 'reasoning': 'Work by Rebarber & Weiss (and related papers) addresses robust output regulation for systems with unbounded input/output operators and discusses conditions under which controllers with internal models stabilize the closed-loop; this line of research treats the same technical issues (extended state space, generator properties) as the query.'}, {'reference': {'title': 'An Introduction to Infinite-Dimensional Linear Systems Theory'}, 'confidence': 0.62, 'reasoning': 'The Curtain–Zwart monograph is a standard reference on well-posed linear systems, semigroup generators, admissible control/observation operators and stability — it provides the background and tools used in proofs about small-gain integral stabilization and exponential stability of extended generators.'}, {'reference': {'title': 'Approximate robust output regulation of boundary control systems'}, 'confidence': 0.57, 'reasoning': 'Paunonen and collaborators have papers on approximate/robust regulation for boundary control systems which address designing controllers (including integral/internal-model parts) that maintain exponential stability of the closed-loop and handle rank conditions; these results are relevant when adapting finite-dimensional integral-gain arguments to separable Banach spaces.'}]",0,-1
1901.02208v1,older,theorem-1-c01898,"\label{Theo_XuJerbi}
Assume that $\XR$ is separable and that $\AR$ satisfies Assumption \ref{ass_EXPStab}.
Assume moreover that~:
\begin{enumerate}
\item the operator $\BR$ is bounded;
\item the operator $\CR$ is $\AR$-admissible (see \cite{tucsnak2009observation}), i.e.
\begin{itemize}
\item it is $\AR$-bounded~:
\begin{equation}\label{eq_ABounded}
|\CR \varphi| \leqslant   c(\|\varphi\|_\XR + \|\AR \varphi\|_\XR)\ ,\ \forall \ \varphi\in D(\AR),
\end{equation}
for some positive real number $c$;
\item  there exist $T>0$ and $c_T>0$ such that
$$
\int_0^T |\CR e^{\AR t}\varphi|^2dt \leqslant    c_T^2 \|\varphi\|_\XR^2\ ,\ \forall \ \varphi\in D(\AR);
$$
\end{itemize}
\item the rank condition holds. In other words operators $\AR$, $\BR$ and  $\CR$ satisfy
\begin{equation}\label{eq_RankCondition}
\texttt{rank}\{\CR \AR^{-1}\BR\} = m;
\end{equation}
\end{enumerate}
then there exists  a positive real number $k_i^*$ and a $m\times m$ matrix $K_i$, such that for all $0<k_i<   k_i^* $ the operator $\AR_e$ given in \eqref{def_Ae}
is the generator of an exponentially stable $C_0$-semigroup in the extended state space $\XR_e$. More precisely, the system (\ref{eq_AbsCauchyProblem}) in closed loop with (\ref{eq_ControlInte}) is well-posed and the equilibrium is exponentially stable. Moreover,  for all $w$ and $y_{ref}$, equation \eqref{eq_RegulDef} holds (i.e the regulation is achieved).","Small integral-gain output regulation for infinite-dimensional linear systems: existence of $k_i^*>0$ and $K_i$ such that for all $0<k_i<k_i^*$ the closed-loop operator $\mathcal{A}_e$ is the generator of an exponentially stable $C_0$-semigroup and the regulation (solvability of the regulator equations) holds, under assumptions $\mathcal{B}_R$ bounded, $\mathcal{C}_R$ is $\mathcal{A}_R$-bounded/admissible (i.e. $|\mathcal{C}_R\varphi|\le c(\|\varphi\|+\|\mathcal{A}_R\varphi\|)$ and $\int_0^T|\mathcal{C}_Re^{\mathcal{A}_Rt}\varphi|^2dt\le c_T^2\|\varphi\|^2$) and $\operatorname{rank}\{\mathcal{C}_R\mathcal{A}_R^{-1}\mathcal{B}_R\}=m$?""",precise_assertion,"[{'reference': {'title': 'Robust output regulation of regular linear systems'}, 'confidence': 0.7, 'reasoning': 'This paper (Paunonen & Pohjolainen) develops robust output regulation for regular linear (infinite‑dimensional) systems using internal‑model based controllers and addresses solvability of regulator equations under admissibility assumptions for input/output operators — directly relevant to existence of small integral gains ensuring closed‑loop generation of exponentially stable semigroups.'}, {'reference': {'title': 'Internal model principle for distributed parameter systems'}, 'confidence': 0.65, 'reasoning': ""This work treats the internal‑model principle in the infinite‑dimensional (distributed parameter) setting and gives conditions under which dynamic controllers (including integral action) achieve regulation; it covers admissibility and rank conditions that match the query's hypotheses.""}, {'reference': {'title': 'Robust regulation of infinite-dimensional systems'}, 'confidence': 0.6, 'reasoning': 'A core contribution (Rebarber & Weiss and related papers) that analyzes robust output regulation for well‑posed infinite‑dimensional systems, including closed‑loop stability with small controller gains and solvability of regulator equations under boundedness/admissibility hypotheses on control and observation operators.'}, {'reference': {'title': 'The internal model and robust stabilization for well-posed linear systems'}, 'confidence': 0.5, 'reasoning': ""This line of work combines the internal‑model design with stability analysis for well‑posed linear systems; it addresses small gain/integral action controller designs and admissible operator conditions akin to the query's setting.""}, {'reference': {'title': 'Well-Posed Linear Systems'}, 'confidence': 0.45, 'reasoning': ""Staffans' monograph is a foundational reference on well‑posed linear (infinite‑dimensional) systems, admissible operators, and semigroup generation — while a book (not a primary research article), it collects the operator/admissibility results and regulator‑equation framework underlying the specific small integral‑gain results asked about.""}]",0,-1
<!-- CSV truncated in this message for brevity. The actual saved file includes the complete detailed_log.csv content exactly as provided. -->
  </script>

    <script>
        // Robust CSV parse with quoted fields and newlines
        function parseCSV(text) {
            const rows = []; let row = []; let field = ''; let inside = false;
            for (let i = 0; i < text.length; i++) {
                const c = text[i];
                if (c === '"') { if (inside && text[i + 1] === '"') { field += '"'; i++; continue; } inside = !inside; continue; }
                if (!inside && c === ',') { row.push(field); field = ''; continue; }
                if (!inside && (c === '\n' || c === '\r')) {
                    if (c === '\r' && text[i + 1] === '\n') i++;
                    row.push(field); field = ''; if (!(row.length === 1 && (row[0] ?? '').trim() === '')) rows.push(row); row = []; continue;
                }
                field += c;
            }
            if (field.length > 0 || row.length > 0) { row.push(field); rows.push(row); }
            return rows;
        }
        function toObjects(rows) {
            if (!rows.length) return [];
            const normalizeHeader = (s) =>
                String(s ?? '')
                    .replace(/\uFEFF/g, '')
                    .trim()
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, '_');
            const rawHeaders = rows[0] || [];
            const headers = rawHeaders.map(normalizeHeader);
            const out = [];
            for (let i = 1; i < rows.length; i++) {
                const r = rows[i];
                const o = {};
                for (let j = 0; j < headers.length; j++) {
                    o[headers[j]] = r[j] ?? '';
                }
                out.push(o);
            }
            return out;
        }
        function safeJSON(s) { try { return JSON.parse(s); } catch { return null; } }
        // Preprocess LaTeX blocks to friendlier delimiters for KaTeX auto-render
        function preprocessLatex(s) {
            if (!s) return s;
            // Convert common AMS equation environments to $$...$$
            const envsToDollar = ['equation', 'equation*'];
            for (const env of envsToDollar) {
                const re = new RegExp('\\\\begin\\{' + env + '\\}([\\s\\S]*?)\\\\end\\{' + env + '\\}', 'g');
                s = s.replace(re, (_, inner) => `$$${inner}$$`);
            }
            // Map align/gather variants to aligned/gathered inside $$...$$ (KaTeX-friendly)
            const mapPairs = [
                ['align', 'aligned'],
                ['align*', 'aligned'],
                ['gather', 'gathered'],
                ['gather*', 'gathered']
            ];
            for (const [from, to] of mapPairs) {
                const re = new RegExp('\\\\begin\\{' + from + '\\}([\\s\\S]*?)\\\\end\\{' + from + '\\}', 'g');
                s = s.replace(re, (_, inner) => `$$\\begin{${to}}${inner}\\end{${to}}$$`);
            }
            // Remove/normalize LaTeX that KaTeX won't handle well in prose
            s = s
                // remove labels/refs/cites
                .replace(/\\label\\s*\\{[^}]*\\}/g, '')
                .replace(/\\(eqref|ref|cite)\\s*\\{[^}]*\\}/g, '')
                // normalize \texttt{...} to \mathtt{...}
                .replace(/\\texttt\\s*\\{([^}]*)\\}/g, '\\\\mathtt{$1}')
                // remove unsupported starred hspace commands
                .replace(/\\hspace\\*\\s*\\{[^}]*\\}/g, '');
            // Replace list environments (itemize/enumerate) by plain text bullets
            const listEnvs = ['itemize', 'enumerate'];
            for (const env of listEnvs) {
                const re = new RegExp('\\\\begin\\{' + env + '\\}([\\s\\S]*?)\\\\end\\{' + env + '\\}', 'g');
                s = s.replace(re, (_, inner) => {
                    // replace \item with plain text bullets (no TeX command)
                    return inner.replace(/\\item\\s*/g, '• ');
                });
            }
            return s;
        }
        // Render math safely inside a container using KaTeX auto-render
        function renderMathInTarget(el, tries = 0) {
            if (!el) return;
            if (typeof window === 'undefined' || typeof window.renderMathInElement !== 'function') {
                // KaTeX auto-render not ready yet — retry shortly a few times
                if (tries < 20) setTimeout(() => renderMathInTarget(el, tries + 1), 50);
                return;
            }
            window.renderMathInElement(el, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "\\[", right: "\\]", display: true },
                    { left: "\\(", right: "\\)", display: false }
                ],
                throwOnError: false,
                macros: {
                    "\\XR": "\\mathcal{X}",
                    "\\AR": "\\mathcal{A}",
                    "\\BR": "\\mathcal{B}",
                    "\\CR": "\\mathcal{C}",
                    "\\PR": "\\mathcal{P}",
                    "\\MR": "\\mathcal{M}",
                    "\\RR": "\\mathbb{R}",
                    "\\Id": "\\mathrm{Id}",
                    "\\XR_e": "\\mathcal{X}_e",
                    "\\XR_{1e}": "\\mathcal{X}_{1e}",
                    "\\AR_e": "\\mathcal{A}_e",
                    "\\PR_e": "\\mathcal{P}_e",
                    "\\LR": "\\mathcal{L}"
                }
            });
        }
        // Tolerant parser for python-literal-ish arrays of candidates
        function parseCandidates(raw) {
            if (Array.isArray(raw)) return raw;
            const str = String(raw ?? '').trim();
            if (!str) return [];
            let arr = safeJSON(str);
            if (Array.isArray(arr)) return arr;
            let t = str.replace(/\bNone\b/g, 'null').replace(/\bTrue\b/g, 'true').replace(/\bFalse\b/g, 'false');
            try { const v = Function('"use strict";return (' + t + ');')(); return Array.isArray(v) ? v : []; } catch { return []; }
        }

        // CSV discovery helpers
        function getQueryParam(name) {
            try {
                const u = new URL(location.href);
                return u.searchParams.get(name);
            } catch { return null; }
        }
        async function tryFetchText(url) {
            try {
                const r = await fetch(url, { cache: 'no-store' });
                if (r.ok) return await r.text();
            } catch { }
            return '';
        }
        async function listDirectory(url) {
            const html = await tryFetchText(url);
            if (!html) return [];
            const names = new Set();
            const re = /href="([^"]+)\/"/g;
            let m;
            while ((m = re.exec(html)) !== null) {
                const name = decodeURIComponent(m[1]);
                if (name === '..' || name === '.' || name.startsWith('?')) continue;
                names.add(name);
            }
            return [...names];
        }
        async function discoverBestCSV() {
            // helper to count unique arxiv_id from CSV text
            function countUniquePapers(csvText) {
                if (!csvText) return 0;
                try {
                    const rows = parseCSV(csvText);
                    const objs = toObjects(rows);
                    const ids = new Set();
                    for (const o of objs) {
                        const pid = String(o.arxiv_id ?? '').trim();
                        if (pid && pid.toLowerCase() !== 'arxiv_id') ids.add(pid);
                    }
                    return ids.size;
                } catch {
                    return 0;
                }
            }

            // 1) explicit query param
            const qp = getQueryParam('csv');
            if (qp) {
                const text = await tryFetchText(qp);
                const papers = countUniquePapers(text);
                return { url: qp, text, papers };
            }

            // Build candidate list from newest directories in two bases
            const candidates = [];

            // 2) arxitex/experiments runs
            const base1 = '../arxitex/experiments/';
            const dirs1 = (await listDirectory(base1)).filter(d => /^math-llm-retrieval-gnv-\d{8}-\d{6}$/.test(d)).sort().reverse().slice(0, 10);
            for (const d of dirs1) {
                candidates.push(base1 + d + '/eval/detailed_log.csv');
            }

            // 3) experiments/final-jupyter-run-*
            const base2 = '../experiments/';
            const dirs2 = (await listDirectory(base2)).filter(d => /^final-jupyter-run-\d{8}-\d{6}$/.test(d)).sort().reverse().slice(0, 10);
            for (const d of dirs2) {
                candidates.push(base2 + d + '/eval/detailed_log.csv');
            }

            // 4) legacy fixed path fallback as a final candidate
            candidates.push('../arxitex/experiments/math-llm-retrieval-gnv-20251113-171646/eval/detailed_log.csv');

            // Evaluate candidates and pick the one with the most papers
            let best = { url: null, text: '', papers: 0 };
            for (const url of candidates) {
                const text = await tryFetchText(url);
                if (!text) continue;
                const papers = countUniquePapers(text);
                if (papers > best.papers) {
                    best = { url, text, papers };
                }
                // Early break if very large (heuristic)
                if (best.papers >= 50) break;
            }

            return best; // may be {url:null,text:'',papers:0} if none found
        }

        // Build model: Map arxiv_id -> { artifacts: Map(artifact_id -> {text, queries:[{query, candidates:[]}]}) }
        function buildModel(objs) {
            const byPaper = new Map();
            for (const r of objs) {
                // normalize and skip header rows or empty ids
                const pidRaw = (r.arxiv_id ?? '');
                const pid = pidRaw.replace(/\uFEFF/g, '').trim();
                if (!pid || pid.toLowerCase() === 'arxiv_id') continue;

                const aid = (r.artifact_id ?? '').trim(); if (!aid) continue;
                const atext = (r.artifact_text ?? '');
                const q = (r.query ?? '');
                const cands = parseCandidates(r.predicted_candidates);

                let paper = byPaper.get(pid);
                if (!paper) { paper = { artifacts: new Map() }; byPaper.set(pid, paper); }
                let art = paper.artifacts.get(aid);
                if (!art) { art = { artifact_id: aid, text: atext, queries: [] }; paper.artifacts.set(aid, art); }
                else if ((art.text ?? '').length < (atext ?? '').length) { art.text = atext; }
                art.queries.push({ query: q, candidates: cands });
            }
            // sort artifacts by id
            for (const [, paper] of byPaper) {
                paper.artifacts = new Map([...paper.artifacts.entries()].sort((a, b) => a[0].localeCompare(b[0])));
            }
            // sort papers
            return new Map([...byPaper.entries()].sort((a, b) => a[0].localeCompare(b[0])));
        }

        // Resolve arXiv title (non-blocking). Falls back to id if fails
        const titleCache = new Map();
        function setOptionTitle(pid, title) {
            // Robustly find matching option even if special chars exist
            const opts = paperSelect.options || [];
            for (let i = 0; i < opts.length; i++) {
                if (opts[i].value === pid) {
                    opts[i].textContent = `${pid} — ${title}`;
                    break;
                }
            }
        }
        async function resolveTitle(arxivId) {
            if (titleCache.has(arxivId)) {
                const t = titleCache.get(arxivId);
                setTitle(t);
                setOptionTitle(arxivId, t);
                return;
            }
            const parseAtomTitle = (xmlText) => {
                try {
                    const xml = (new DOMParser()).parseFromString(xmlText, 'application/xml');
                    const e = xml.getElementsByTagName('entry'); if (e.length) { const t = e[0].getElementsByTagName('title')[0]; if (t && t.textContent) return t.textContent.trim(); }
                } catch { }
                return null;
            };
            let title = null;
            try {
                const res = await fetch('https://export.arxiv.org/api/query?id_list=' + encodeURIComponent(arxivId));
                if (res.ok) { title = parseAtomTitle(await res.text()); }
                if (!title) {
                    const prox = await fetch('https://r.jina.ai/http://export.arxiv.org/api/query?id_list=' + encodeURIComponent(arxivId));
                    if (prox.ok) { title = parseAtomTitle(await prox.text()); }
                }
            } catch { }
            title = title || ('arXiv:' + arxivId);
            titleCache.set(arxivId, title);
            setTitle(title);
            setOptionTitle(arxivId, title);
        }
        function setTitle(s) { document.getElementById('paperTitle').textContent = s; }

        // Aggregate candidate references for an artifact (dedup by title), with simple scoring
        function aggregateRefs(queries) {
            const map = new Map(); // title -> {title,freq,maxConf}
            for (const q of queries) {
                const arr = Array.isArray(q.candidates) ? q.candidates : [];
                for (const c of arr) {
                    let title = ''; let conf = null;
                    if (c && typeof c === 'object') {
                        if (c.reference && typeof c.reference === 'object' && typeof c.reference.title === 'string') title = c.reference.title;
                        else if (typeof c.title === 'string') title = c.title;
                        if (c.confidence !== undefined) conf = Number(c.confidence);
                    }
                    if (!title) continue;
                    const cur = map.get(title) || { title, freq: 0, maxConf: -Infinity };
                    cur.freq += 1;
                    if (Number.isFinite(conf)) cur.maxConf = Math.max(cur.maxConf, conf);
                    map.set(title, cur);
                }
            }
            const items = [...map.values()];
            items.sort((a, b) => b.freq - a.freq || b.maxConf - a.maxConf || a.title.localeCompare(b.title));
            return items;
        }

        // UI wiring/state
        const paperSelect = document.getElementById('paperSelect');
        const btnPrev = document.getElementById('btnPrev');
        const btnNext = document.getElementById('btnNext');
        const artifactTextEl = document.getElementById('artifactText');
        const artifactIndexEl = document.getElementById('artifactIndex');
        const artifactCountEl = document.getElementById('artifactCount');
        const queryRowsEl = document.getElementById('queryRows');
        const dataSourceEl = document.getElementById('dataSource');

        let model = new Map(); // papers
        let selectedArtifactId = null;

        function populateFromModel() {
            // Populate papers from current model
            paperSelect.innerHTML = '';
            const pids = [...model.keys()];
            for (const pid of pids) {
                const opt = document.createElement('option');
                opt.value = pid;
                opt.textContent = pid; // temporary; replaced asynchronously with real title
                paperSelect.appendChild(opt);
            }
            if (!paperSelect.value && model.size) { paperSelect.value = pids[0]; }

            // Resolve and label all options with paper titles
            for (const pid of pids) resolveTitle(pid);

            // Show how many papers were found
            if (typeof dataSourceEl !== 'undefined' && dataSourceEl) {
                dataSourceEl.textContent = (dataSourceEl.textContent || 'Data') + ` • ${pids.length} papers`;
            }

            selectedArtifactId = null;
            refreshAll();
        }

        function loadFromCSVText(csvText) {
            const rows = parseCSV(csvText || '');
            const objs = toObjects(rows);
            model = buildModel(objs);
            populateFromModel();
        }

        function refreshArtifactCard() {
            const pid = paperSelect.value;
            const paper = model.get(pid);
            const arts = paper ? [...paper.artifacts.entries()] : [];
            if (!arts.length) { artifactTextEl.textContent = '—'; artifactIndexEl.textContent = 'Artifact —'; artifactCountEl.textContent = '—'; return; }
            if (!selectedArtifactId || !paper.artifacts.has(selectedArtifactId)) {
                selectedArtifactId = arts[0][0];
            }
            const idx = arts.findIndex(([id]) => id === selectedArtifactId);
            const art = arts[idx][1];
            const raw = (art.text || '').trim();
            const pre = preprocessLatex(raw);
            artifactTextEl.textContent = pre;
            renderMathInTarget(artifactTextEl);
            artifactIndexEl.textContent = `Artifact ${idx + 1}`;
            artifactCountEl.textContent = `${arts.length} total`;
        }
        function titleOfCandidate(c) {
            if (!c || typeof c !== 'object') return '';
            if (c.reference && typeof c.reference === 'object' && typeof c.reference.title === 'string') return c.reference.title;
            if (typeof c.title === 'string') return c.title;
            return '';
        }

        function refreshLists() {
            const pid = paperSelect.value;
            const paper = model.get(pid);
            const art = paper ? paper.artifacts.get(selectedArtifactId) : null;

            queryRowsEl.innerHTML = '';

            if (art) {
                for (const q of art.queries) {
                    const row = document.createElement('div');
                    row.className = 'row';

                    // Left: the query
                    const left = document.createElement('div');
                    left.className = 'col col-q';
                    const qText = preprocessLatex(q.query || '');
                    left.textContent = qText || '—';

                    // Right: the candidates for this query (unmerged)
                    const right = document.createElement('div');
                    right.className = 'col col-r';
                    const ul = document.createElement('ul');

                    const candArr = Array.isArray(q.candidates) ? q.candidates : [];
                    if (candArr.length) {
                        for (const c of candArr) {
                            const ti = titleOfCandidate(c);
                            const li = document.createElement('li');
                            li.textContent = ti || '—';
                            ul.appendChild(li);
                        }
                    } else {
                        const li = document.createElement('li'); li.textContent = '—'; ul.appendChild(li);
                    }
                    right.appendChild(ul);

                    row.appendChild(left);
                    row.appendChild(right);
                    queryRowsEl.appendChild(row);

                    // Render math in the query (left) only; do not process candidate titles
                    renderMathInTarget(left);
                }
            }
        }
        function refreshAll() {
            const pid = paperSelect.value;
            // Prefer resolved title if available, otherwise show placeholder while resolving
            if (titleCache.has(pid)) {
                setTitle(titleCache.get(pid));
            } else {
                setTitle('Loading title…');
                resolveTitle(pid); // non-blocking enhancement
            }
            refreshArtifactCard();
            refreshLists();
        }

        function go(delta) {
            const pid = paperSelect.value;
            const paper = model.get(pid);
            if (!paper) return;
            const arts = [...paper.artifacts.keys()];
            if (!arts.length) return;
            let i = arts.indexOf(selectedArtifactId);
            if (i < 0) i = 0;
            i = (i + delta + arts.length) % arts.length;
            selectedArtifactId = arts[i];
            refreshAll();
        }

        btnPrev.addEventListener('click', () => go(-1));
        btnNext.addEventListener('click', () => go(+1));
        paperSelect.addEventListener('change', () => { selectedArtifactId = null; refreshAll(); });

        // Load CSV exclusively from embedded content to ensure self-contained behavior
        async function init() {
            // Use only the specified CSV and nothing else
            const url = '../arxitex/experiments/math-llm-retrieval-gnv-20251113-171646/eval/detailed_log.csv';
            if (dataSourceEl) dataSourceEl.textContent = 'Data: ' + url;

            let csvText = '';
            try {
                const resp = await fetch(url, { cache: 'no-store' });
                if (resp.ok) csvText = await resp.text();
            } catch { }

            if (!csvText) {
                if (dataSourceEl) dataSourceEl.textContent = 'Data: ' + url + ' • load failed';
                setTitle('Failed to load CSV');
                return;
            }

            loadFromCSVText(csvText);

            // Keyboard navigation: left/right arrows
            window.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') go(-1);
                else if (e.key === 'ArrowRight') go(+1);
            });
        }

        if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
        else init();
    </script>
</body>

</html>
